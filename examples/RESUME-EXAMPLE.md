# RESUME - User Authentication Feature

*Generated by /reheat:save on 2026-01-01*

## OBJECTIVE

Implement JWT-based authentication system for the Express.js API with:
- User registration and login
- Access token + refresh token pattern
- Protected route middleware
- Token refresh endpoint

**Why:** Current API has no authentication, allowing unrestricted access to user data endpoints.

## CURRENT STATUS

**Progress: ~60% complete**

### ‚úÖ Completed
- User registration endpoint (`POST /api/auth/register`)
- Password hashing with bcrypt
- User model with email, password, refreshToken fields
- Login endpoint (`POST /api/auth/login`)
- JWT access token generation (15min expiry)
- JWT refresh token generation (7 days expiry)

### üîÑ In Progress
- Refresh token endpoint implementation (started, not working)

### ‚è≥ Not Started
- Auth middleware for protected routes
- Token blacklist/invalidation system
- Integration tests for auth flows
- Rate limiting on auth endpoints

## RECENT CHANGES

### Modified Files
- [routes/auth.ts](routes/auth.ts) - Added register (lines 8-32) and login (lines 34-58) endpoints
- [services/jwt.ts](services/jwt.ts) - Created token generation functions
  - `generateAccessToken(userId: string): string` at line 12
  - `generateRefreshToken(userId: string): string` at line 20
- [models/User.ts](models/User.ts) - Added `refreshToken?: string` field at line 15
- [config/env.ts](config/env.ts) - Added JWT_SECRET and JWT_REFRESH_SECRET

### Database Changes
- Added migration `20260101_add_refresh_token_to_users.sql`
- Adds `refresh_token` TEXT column to users table

## WHAT FAILED

### ‚ùå Attempt 1: App-Level JWT Middleware

**What I tried:**
```typescript
// app.ts
app.use(jwtMiddleware); // Apply to all routes
```

**Error:**
```
TokenExpiredError: jwt expired
    at JsonWebTokenError.verify (node_modules/jsonwebtoken/verify.js:147:19)
    at middleware/auth.ts:23:28
```

**Why it failed:**
- Middleware ran on EVERY request including auth routes
- Token expiration happened before refresh logic could run
- Created circular dependency: need valid token to refresh token

**What I learned:**
- Middleware needs to run AFTER auth routes, or
- Auth routes need to be explicitly excluded, or
- Better: only protect specific routes that need auth

---

### ‚ùå Attempt 2: Refresh Token in Memory

**What I tried:**
Stored refresh tokens in a Map in memory instead of database

**Error:**
Tokens were lost on server restart. User session test failed:
```bash
npm test auth.test.ts
# Test "should maintain session after server restart" failed
# Expected: 200, Got: 401 Unauthorized
```

**Why it failed:**
- In-memory storage is not persistent
- Development restarts cleared all refresh tokens
- Production scaling would lose tokens across instances

**What I learned:**
- Refresh tokens MUST be in persistent storage (database)
- Allows token invalidation (logout, security breach)
- Enables cross-instance session management

## KEY DECISIONS

### Decision 1: JWT Over Sessions
**Chosen:** JWT tokens
**Rejected:** Express sessions with Redis
**Rationale:**
- Stateless - easier to scale horizontally
- Works well with microservices architecture
- Mobile app clients handle tokens naturally
- No Redis dependency

**Tradeoffs:**
- Can't invalidate access tokens before expiry (short expiry mitigates this)
- Slightly larger request size with token in header
- Need refresh token strategy for long-lived sessions

---

### Decision 2: Short-Lived Access Tokens
**Chosen:** 15 minute access token expiry
**Alternatives considered:** 1 hour, 24 hours
**Rationale:**
- Limits damage if access token is compromised
- Forces regular refresh (allows checking if user still valid)
- Industry standard for security-sensitive apps

**Tradeoffs:**
- More frequent refresh requests
- Need refresh token implementation to avoid constant re-login

---

### Decision 3: Database Storage for Refresh Tokens
**Chosen:** Store refresh tokens in users table
**Rejected:** Separate refresh_tokens table, in-memory, no storage
**Rationale:**
- Allows immediate invalidation on logout
- Can revoke all user sessions (security)
- Simpler than separate table for MVP
- Persistent across server restarts

**Future consideration:** May move to separate table if need multiple devices per user

## CURRENT ISSUES

### Issue 1: Refresh Token Endpoint Returns 500

**Location:** [routes/auth.ts:60-78](routes/auth.ts:L60-L78)

**Reproduction:**
```bash
# First, login to get tokens
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@example.com","password":"password123"}'

# Response: {"accessToken":"eyJ...", "refreshToken":"eyJ..."}

# Try to refresh
curl -X POST http://localhost:3000/api/auth/refresh \
  -H "Content-Type: application/json" \
  -d '{"refreshToken":"eyJ..."}'
```

**Expected:** 200 with new access token
```json
{"accessToken":"eyJ..."}
```

**Actual:** 500 Internal Server Error
```json
{"error":"Cannot read property 'id' of undefined"}
```

**Error Location:** [routes/auth.ts:67](routes/auth.ts:L67)
```typescript
const userId = decoded.id; // decoded is undefined
```

**Root Cause:** JWT verification failing but error not caught properly. Need to check token verification before accessing decoded payload.

---

### Issue 2: No Test Coverage

**Problem:** Auth endpoints have no automated tests
**Impact:** Breaking changes not caught until manual testing
**Files affected:** All auth routes

## NEXT STEPS

### Priority 1: Fix Refresh Token Endpoint
1. Add proper error handling around jwt.verify() in [routes/auth.ts:65](routes/auth.ts:L65)
2. Check if decoded payload exists before accessing properties
3. Verify refresh token exists in database and matches
4. Test with curl commands above

**Estimated effort:** 30-45 minutes

---

### Priority 2: Implement Auth Middleware
1. Create route-specific middleware in [middleware/auth.ts](middleware/auth.ts)
2. Verify access token (not refresh token)
3. Attach user ID to req.user
4. Apply only to protected routes, NOT auth routes

**Example usage:**
```typescript
app.get('/api/users/me', authMiddleware, getUserProfile);
```

**Estimated effort:** 1 hour

---

### Priority 3: Add Integration Tests
1. Create [tests/auth.test.ts](tests/auth.test.ts)
2. Test cases needed:
   - Register new user (success + duplicate email)
   - Login with valid credentials
   - Login with invalid credentials
   - Refresh access token with valid refresh token
   - Refresh with invalid/expired refresh token
   - Access protected route with valid token
   - Access protected route with expired token

**Estimated effort:** 2 hours

---

### Priority 4: Secure Improvements
- Add rate limiting to login/register (prevent brute force)
- Implement token blacklist for logout
- Add password strength requirements
- Hash refresh tokens in database (currently stored plain)

**Estimated effort:** 3-4 hours

## TECHNICAL CONTEXT

### Code Structure

**Key Files:**
- [routes/auth.ts](routes/auth.ts) - Auth endpoints (register, login, refresh)
- [services/jwt.ts](services/jwt.ts) - Token generation and verification
- [models/User.ts](models/User.ts) - User model with Sequelize ORM
- [middleware/auth.ts](middleware/auth.ts) - Auth middleware (not implemented yet)
- [config/env.ts](config/env.ts) - Environment variables

**Important Functions:**

```typescript
// services/jwt.ts:12
function generateAccessToken(userId: string): string
// Creates 15min JWT with payload {id: userId}

// services/jwt.ts:20
function generateRefreshToken(userId: string): string
// Creates 7-day JWT with payload {id: userId}

// services/jwt.ts:28
function verifyAccessToken(token: string): {id: string} | null
// Verifies and decodes access token

// models/User.ts:45
async function User.findByEmail(email: string): Promise<User | null>
// Find user by email

// models/User.ts:52
async function User.comparePassword(password: string): Promise<boolean>
// Compare hashed password
```

### Environment & Setup

**Required Environment Variables:**
```bash
JWT_SECRET=your-secret-key-here            # For access tokens
JWT_REFRESH_SECRET=your-refresh-secret     # For refresh tokens
DATABASE_URL=postgresql://localhost/myapp
```

**Dependencies Added:**
```json
{
  "jsonwebtoken": "^9.0.0",
  "bcrypt": "^5.1.0"
}
```

**Database Setup:**
```bash
# Run migrations
npm run migrate

# Create test user
npm run seed
```

**Start Server:**
```bash
npm run dev
# Runs on http://localhost:3000
```

### Testing

**No tests exist yet** - this is Priority 3

**To run tests (once created):**
```bash
npm test                    # All tests
npm test auth.test.ts      # Just auth tests
```

**Test Database:**
Uses separate `myapp_test` database (configured in [config/database.ts](config/database.ts))

## IMPORTANT NOTES

### Gotchas

1. **Token Secrets Must Be Different:**
   - JWT_SECRET and JWT_REFRESH_SECRET MUST be different values
   - Using same secret allows refresh token to work as access token
   - Security vulnerability if same secret

2. **Password Hashing Rounds:**
   - Currently using bcrypt with 10 rounds
   - Don't change this without re-hashing all passwords
   - Located at [services/auth.ts:8](services/auth.ts:L8)

3. **Token Expiry Format:**
   - jsonwebtoken library uses strings like "15m", "7d"
   - NOT milliseconds or seconds
   - See [config/env.ts:12-13](config/env.ts:L12-L13)

### Performance Considerations

- JWT verification is synchronous - blocks event loop
- Consider using `jwt.verify` async version for production
- Current implementation fine for <1000 req/s

### Security Concerns

‚ö†Ô∏è **Refresh tokens stored as plaintext** in database
- Should hash them like passwords
- Priority 4 item, but important for production

‚ö†Ô∏è **No rate limiting** on login endpoint
- Vulnerable to brute force attacks
- Add express-rate-limit before launch

‚ö†Ô∏è **Error messages leak user existence**
- "Invalid password" vs "User not found"
- Should both return "Invalid credentials"

### Browser/Platform Compatibility

- Works with any HTTP client
- Tokens in Authorization header: `Bearer <token>`
- No browser-specific code, works with mobile apps

## REFERENCES

### Documentation Consulted
- [jsonwebtoken npm package](https://www.npmjs.com/package/jsonwebtoken)
- [JWT.io - Introduction to JWT](https://jwt.io/introduction)
- [OWASP JWT Cheat Sheet](https://cheatsheetseries.owasp.org/cheatsheets/JSON_Web_Token_for_Java_Cheat_Sheet.html)

### Similar Implementations
- [passport-jwt strategy](https://www.passportjs.org/packages/passport-jwt/) - Alternative approach using Passport
- [Example JWT Auth in Express](https://github.com/auth0/node-jsonwebtoken/tree/master/examples) - Reference implementation

### Relevant Issues/Discussions
- [Should refresh tokens be stored in DB?](https://stackoverflow.com/questions/27726066/) - Yes, for security
- [Access token expiration best practices](https://stackoverflow.com/questions/26739167/) - 15min is reasonable

---

**Next Agent:** Start with Priority 1 (fix refresh endpoint). The error is in token verification logic. Previous attempts at app-level middleware and in-memory tokens both failed for the reasons documented above. Don't retry those approaches.

**Questions?** Check the code in [routes/auth.ts](routes/auth.ts) and [services/jwt.ts](services/jwt.ts) for current implementation details.

